#calling my_knn_cv
cv_error_rates <- vector()
tse_rates <- vector()
for (i in 1:10) {
output <- my_knn_cv(train = my_df, cl = "species", k_nn = i, k_cv = 5)
cv_error_rates[i] <- output[[1]]
tse_rates[i] <- sum(as.character(output[[2]]) != my_df_class) /
length(my_df_class)
}
devtools::document()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
#sometimes library() does not work, we can use the require()
#require(HaoZheng)
library(HaoZheng)
library(randomForest)
library(stringr)
library(class)
library(ggplot2)
library(kableExtra)
library(dplyr,warn.conflicts = FALSE)
data("my_gapminder")
data("my_penguins")
# change my_penguins so that there is no empty value in it
my_penguins_df <- my_penguins
my_penguins_df <- na.omit(my_penguins_df)
# do a two sided t.test with mu = 60
my_t.test(my_gapminder$lifeExp, "two.sided", 60)
# do a one sided t.test with mu = 60
my_t.test(my_gapminder$lifeExp, "less", 60)
# do a one sided t.test with mu = 60
my_t.test(my_gapminder$lifeExp, "greater", 60)
#using my_lm to fit the values
lm_1 <- my_lm(lifeExp ~ gdpPercap + continent, data = my_gapminder)
lm_1
# set up the data
object <- lifeExp ~ gdpPercap + continent
model <- model.frame(object, my_gapminder)
exp  <- model.matrix(object, my_gapminder)
res <- model.response(model) %>% as.matrix()
# plot actual vs fitted
my_lifeExp <- exp %*% lm_1[,1]+ lm_1[,2]
my_plot <- data.frame("actual" = my_gapminder$lifeExp, "fitted" = my_lifeExp,
"color" = my_gapminder$continent)
my_plot %>%
ggplot(aes(x = my_lifeExp, y = my_gapminder$lifeExp, color = color)) +
geom_abline(slope = 1, intercept = 0, col = "black") +
geom_point() +
coord_flip() +
labs(title = "Actual vs. Fitted Values", x = "fitted",
y = "actual", color = "Continent")
#setting up penguins data set
my_df <- my_penguins
my_df <- my_df %>%
dplyr::select(c(species, bill_length_mm, bill_depth_mm,
flipper_length_mm, body_mass_g))
my_df$species <- as.character(my_df$species)
my_df <- na.omit(my_df)
my_df_class <- my_df %>% dplyr::pull(species)
#calling my_knn_cv
cv_error_rates <- vector()
tse_rates <- vector()
for (i in 1:10) {
output <- my_knn_cv(train = my_df, cl = "species", k_nn = i, k_cv = 5)
cv_error_rates[i] <- output[[1]]
tse_rates[i] <- sum(as.character(output[[2]]) != my_df_class) /
length(my_df_class)
}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
#sometimes library() does not work, we can use the require()
#require(HaoZheng)
library(HaoZheng)
library(randomForest)
library(stringr)
library(class)
library(ggplot2)
library(kableExtra)
library(dplyr,warn.conflicts = FALSE)
data("my_gapminder")
data("my_penguins")
# change my_penguins so that there is no empty value in it
my_penguins_df <- my_penguins
my_penguins_df <- na.omit(my_penguins_df)
# do a two sided t.test with mu = 60
my_t.test(my_gapminder$lifeExp, "two.sided", 60)
# do a one sided t.test with mu = 60
my_t.test(my_gapminder$lifeExp, "less", 60)
# do a one sided t.test with mu = 60
my_t.test(my_gapminder$lifeExp, "greater", 60)
#using my_lm to fit the values
lm_1 <- my_lm(lifeExp ~ gdpPercap + continent, data = my_gapminder)
lm_1
# set up the data
object <- lifeExp ~ gdpPercap + continent
model <- model.frame(object, my_gapminder)
exp  <- model.matrix(object, my_gapminder)
res <- model.response(model) %>% as.matrix()
# plot actual vs fitted
my_lifeExp <- exp %*% lm_1[,1]+ lm_1[,2]
my_plot <- data.frame("actual" = my_gapminder$lifeExp, "fitted" = my_lifeExp,
"color" = my_gapminder$continent)
my_plot %>%
ggplot(aes(x = my_lifeExp, y = my_gapminder$lifeExp, color = color)) +
geom_abline(slope = 1, intercept = 0, col = "black") +
geom_point() +
coord_flip() +
labs(title = "Actual vs. Fitted Values", x = "fitted",
y = "actual", color = "Continent")
#setting up penguins data set
my_df <- my_penguins
my_df <- my_df %>%
dplyr::select(c(species, bill_length_mm, bill_depth_mm,
flipper_length_mm, body_mass_g))
my_df$species <- as.character(my_df$species)
my_df <- na.omit(my_df)
my_df_class <- my_df %>% dplyr::pull(species)
#calling my_knn_cv
cv_error_rates <- vector()
tse_rates <- vector()
for (i in 1:10) {
output <- my_knn_cv(train = my_df, cl = "species", k_nn = i, k_cv = 5)
cv_error_rates[i] <- output[[1]]
tse_rates[i] <- sum(as.character(output[[2]]) != my_df_class) /
length(my_df_class)
}
devtools:document()
devtools::document()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
#sometimes library() does not work, we can use the require()
#require(HaoZheng)
library(HaoZheng)
library(randomForest)
library(stringr)
library(class)
library(ggplot2)
library(kableExtra)
library(dplyr,warn.conflicts = FALSE)
data("my_gapminder")
data("my_penguins")
# change my_penguins so that there is no empty value in it
my_penguins_df <- my_penguins
my_penguins_df <- na.omit(my_penguins_df)
# do a two sided t.test with mu = 60
my_t.test(my_gapminder$lifeExp, "two.sided", 60)
# do a one sided t.test with mu = 60
my_t.test(my_gapminder$lifeExp, "less", 60)
# do a one sided t.test with mu = 60
my_t.test(my_gapminder$lifeExp, "greater", 60)
#using my_lm to fit the values
lm_1 <- my_lm(lifeExp ~ gdpPercap + continent, data = my_gapminder)
lm_1
# set up the data
object <- lifeExp ~ gdpPercap + continent
model <- model.frame(object, my_gapminder)
exp  <- model.matrix(object, my_gapminder)
res <- model.response(model) %>% as.matrix()
# plot actual vs fitted
my_lifeExp <- exp %*% lm_1[,1]+ lm_1[,2]
my_plot <- data.frame("actual" = my_gapminder$lifeExp, "fitted" = my_lifeExp,
"color" = my_gapminder$continent)
my_plot %>%
ggplot(aes(x = my_lifeExp, y = my_gapminder$lifeExp, color = color)) +
geom_abline(slope = 1, intercept = 0, col = "black") +
geom_point() +
coord_flip() +
labs(title = "Actual vs. Fitted Values", x = "fitted",
y = "actual", color = "Continent")
#setting up penguins data set
my_df <- my_penguins
my_df <- my_df %>%
dplyr::select(c(species, bill_length_mm, bill_depth_mm,
flipper_length_mm, body_mass_g))
my_df$species <- as.character(my_df$species)
my_df <- na.omit(my_df)
my_df_class <- my_df %>% dplyr::pull(species)
#calling my_knn_cv
cv_error_rates <- vector()
tse_rates <- vector()
for (i in 1:10) {
output <- my_knn_cv(train = my_df, cl = "species", k_nn = i, k_cv = 5)
cv_error_rates[i] <- output[[1]]
tse_rates[i] <- sum(as.character(output[[2]]) != my_df_class) /
length(my_df_class)
}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
#sometimes library() does not work, we can use the require()
#require(HaoZheng)
library(HaoZheng)
library(randomForest)
library(stringr)
library(class)
library(ggplot2)
library(kableExtra)
library(dplyr,warn.conflicts = FALSE)
data("my_gapminder")
data("my_penguins")
# change my_penguins so that there is no empty value in it
my_penguins_df <- my_penguins
my_penguins_df <- na.omit(my_penguins_df)
# do a two sided t.test with mu = 60
my_t.test(my_gapminder$lifeExp, "two.sided", 60)
# do a one sided t.test with mu = 60
my_t.test(my_gapminder$lifeExp, "less", 60)
# do a one sided t.test with mu = 60
my_t.test(my_gapminder$lifeExp, "greater", 60)
#using my_lm to fit the values
lm_1 <- my_lm(lifeExp ~ gdpPercap + continent, data = my_gapminder)
lm_1
# set up the data
object <- lifeExp ~ gdpPercap + continent
model <- model.frame(object, my_gapminder)
exp  <- model.matrix(object, my_gapminder)
res <- model.response(model) %>% as.matrix()
# plot actual vs fitted
my_lifeExp <- exp %*% lm_1[,1]+ lm_1[,2]
my_plot <- data.frame("actual" = my_gapminder$lifeExp, "fitted" = my_lifeExp,
"color" = my_gapminder$continent)
my_plot %>%
ggplot(aes(x = my_lifeExp, y = my_gapminder$lifeExp, color = color)) +
geom_abline(slope = 1, intercept = 0, col = "black") +
geom_point() +
coord_flip() +
labs(title = "Actual vs. Fitted Values", x = "fitted",
y = "actual", color = "Continent")
#setting up penguins data set
my_df <- my_penguins
my_df <- my_df %>%
dplyr::select(c(species, bill_length_mm, bill_depth_mm,
flipper_length_mm, body_mass_g))
my_df$species <- as.character(my_df$species)
my_df <- na.omit(my_df)
my_df_class <- my_df %>% dplyr::pull(species)
#calling my_knn_cv
cv_error_rates <- vector()
tse_rates <- vector()
for (i in 1:10) {
output <- my_knn_cv(train = my_df, cl = "species", k_nn = i, k_cv = 5)
cv_error_rates[i] <- output[[1]]
tse_rates[i] <- sum(as.character(output[[2]]) != my_df_class) /
length(my_df_class)
}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
#sometimes library() does not work, we can use the require()
#require(HaoZheng)
library(HaoZheng)
library(randomForest)
library(stringr)
library(class)
library(ggplot2)
library(kableExtra)
library(dplyr,warn.conflicts = FALSE)
data("my_gapminder")
data("my_penguins")
# change my_penguins so that there is no empty value in it
my_penguins_df <- my_penguins
my_penguins_df <- na.omit(my_penguins_df)
# do a two sided t.test with mu = 60
my_t.test(my_gapminder$lifeExp, "two.sided", 60)
# do a one sided t.test with mu = 60
my_t.test(my_gapminder$lifeExp, "less", 60)
# do a one sided t.test with mu = 60
my_t.test(my_gapminder$lifeExp, "greater", 60)
#using my_lm to fit the values
lm_1 <- my_lm(lifeExp ~ gdpPercap + continent, data = my_gapminder)
lm_1
# set up the data
object <- lifeExp ~ gdpPercap + continent
model <- model.frame(object, my_gapminder)
exp  <- model.matrix(object, my_gapminder)
res <- model.response(model) %>% as.matrix()
# plot actual vs fitted
my_lifeExp <- exp %*% lm_1[,1]+ lm_1[,2]
my_plot <- data.frame("actual" = my_gapminder$lifeExp, "fitted" = my_lifeExp,
"color" = my_gapminder$continent)
my_plot %>%
ggplot(aes(x = my_lifeExp, y = my_gapminder$lifeExp, color = color)) +
geom_abline(slope = 1, intercept = 0, col = "black") +
geom_point() +
coord_flip() +
labs(title = "Actual vs. Fitted Values", x = "fitted",
y = "actual", color = "Continent")
my_df <- my_penguins
my_df <- my_df %>%
dplyr::select(c(species, bill_length_mm, bill_depth_mm,
flipper_length_mm, body_mass_g))
my_df$species <- as.character(my_df$species)
my_df <- na.omit(my_df)
my_df_class <- my_df %>% dplyr::pull(species)
cv_error_rates <- vector()
tse_rates <- vector()
for (i in 1:10) {
output <- my_knn_cv(train = my_df, cl = "species", k_nn = i, k_cv = 5)
cv_error_rates[i] <- output[[1]]
tse_rates[i] <- sum(as.character(output[[2]]) != my_df_class) /
length(my_df_class)
}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
#sometimes library() does not work, we can use the require()
#require(HaoZheng)
library(HaoZheng)
library(randomForest)
library(stringr)
library(class)
library(ggplot2)
library(kableExtra)
library(dplyr,warn.conflicts = FALSE)
data("my_gapminder")
data("my_penguins")
# change my_penguins so that there is no empty value in it
my_penguins_df <- my_penguins
my_penguins_df <- na.omit(my_penguins_df)
# do a two sided t.test with mu = 60
my_t.test(my_gapminder$lifeExp, "two.sided", 60)
# do a one sided t.test with mu = 60
my_t.test(my_gapminder$lifeExp, "less", 60)
# do a one sided t.test with mu = 60
my_t.test(my_gapminder$lifeExp, "greater", 60)
#using my_lm to fit the values
lm_1 <- my_lm(lifeExp ~ gdpPercap + continent, data = my_gapminder)
lm_1
# set up the data
object <- lifeExp ~ gdpPercap + continent
model <- model.frame(object, my_gapminder)
exp  <- model.matrix(object, my_gapminder)
res <- model.response(model) %>% as.matrix()
# plot actual vs fitted
my_lifeExp <- exp %*% lm_1[,1]+ lm_1[,2]
my_plot <- data.frame("actual" = my_gapminder$lifeExp, "fitted" = my_lifeExp,
"color" = my_gapminder$continent)
my_plot %>%
ggplot(aes(x = my_lifeExp, y = my_gapminder$lifeExp, color = color)) +
geom_abline(slope = 1, intercept = 0, col = "black") +
geom_point() +
coord_flip() +
labs(title = "Actual vs. Fitted Values", x = "fitted",
y = "actual", color = "Continent")
my_df <- my_penguins
my_df <- my_df %>%
dplyr::select(c(species, bill_length_mm, bill_depth_mm,
flipper_length_mm, body_mass_g))
my_df$species <- as.character(my_df$species)
my_df <- na.omit(my_df)
my_df_class <- my_df %>% dplyr::pull(species)
cv_error_rates <- vector()
tse_rates <- vector()
for (i in 1:10) {
output <- my_knn_cv(train = my_df, cl = "species", k_nn = i, k_cv = 5)
cv_error_rates[i] <- output[[1]]
tse_rates[i] <- sum(as.character(output[[2]]) != my_df_class) /
length(my_df_class)
}
devtools::document()
my_df <- my_penguins
my_df <- my_df %>%
dplyr::select(c(species, bill_length_mm, bill_depth_mm,
flipper_length_mm, body_mass_g))
my_df$species <- as.character(my_df$species)
my_df <- na.omit(my_df)
my_df_class <- my_df %>% dplyr::pull(species)
cv_error_rates <- vector()
tse_rates <- vector()
for (i in 1:10) {
output <- my_knn_cv(train = my_df, cl = "species", k_nn = i, k_cv = 5)
cv_error_rates[i] <- output[[1]]
tse_rates[i] <- sum(as.character(output[[2]]) != my_df_class) /
length(my_df_class)
}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(Stat302Proj2)
#sometimes library() does not work, we can use the require()
#require(HaoZheng)
library(HaoZheng)
library(randomForest)
library(stringr)
library(class)
library(ggplot2)
library(kableExtra)
library(dplyr,warn.conflicts = FALSE)
data("my_gapminder")
data("my_penguins")
# change my_penguins so that there is no empty value in it
my_penguins_df <- my_penguins
my_penguins_df <- na.omit(my_penguins_df)
k_cv <- 5
peng_no_na <- my_penguins %>%
select(
species, bill_length_mm, bill_depth_mm,
flipper_length_mm, body_mass_g
) %>%
drop_na()
k_cv <- 5
peng_no_na <- my_penguins %>%
select(
species, bill_length_mm, bill_depth_mm,
flipper_length_mm, body_mass_g
) %>%
dplyr::drop_na()
k_cv <- 5
peng_no_na <- my_penguins %>%
select(
species, bill_length_mm, bill_depth_mm,
flipper_length_mm, body_mass_g
) %>% drop_na()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
#sometimes library() does not work, we can use the require()
#require(HaoZheng)
library(HaoZheng)
library(randomForest)
library(stringr)
library(class)
library(ggplot2)
library(kableExtra)
library(dplyr,warn.conflicts = FALSE)
data("my_gapminder")
data("my_penguins")
# change my_penguins so that there is no empty value in it
my_penguins_df <- my_penguins
my_penguins_df <- na.omit(my_penguins_df)
# do a two sided t.test with mu = 60
my_t.test(my_gapminder$lifeExp, "two.sided", 60)
# do a one sided t.test with mu = 60
my_t.test(my_gapminder$lifeExp, "less", 60)
# do a one sided t.test with mu = 60
my_t.test(my_gapminder$lifeExp, "greater", 60)
#using my_lm to fit the values
lm_1 <- my_lm(lifeExp ~ gdpPercap + continent, data = my_gapminder)
lm_1
# set up the data
object <- lifeExp ~ gdpPercap + continent
model <- model.frame(object, my_gapminder)
exp  <- model.matrix(object, my_gapminder)
res <- model.response(model) %>% as.matrix()
# plot actual vs fitted
my_lifeExp <- exp %*% lm_1[,1]+ lm_1[,2]
my_plot <- data.frame("actual" = my_gapminder$lifeExp, "fitted" = my_lifeExp,
"color" = my_gapminder$continent)
my_plot %>%
ggplot(aes(x = my_lifeExp, y = my_gapminder$lifeExp, color = color)) +
geom_abline(slope = 1, intercept = 0, col = "black") +
geom_point() +
coord_flip() +
labs(title = "Actual vs. Fitted Values", x = "fitted",
y = "actual", color = "Continent")
# create the matrix
answer <- matrix(NA, nrow = 10, ncol = 2)
rownames(answer) <- c(1:10)
for (i in 1:10) {
output <- my_knn_cv(my_penguins_df[,3:6], my_penguins_df$species, i, 5)
answer[i, 1] <- output$ce
answer[i, 2] <- output$te
}
answer <- data.frame("Neighbour's number" = c(1:10),
"cv misclassification rate" = answer[, 1],
"training misclassification rate" = answer[, 2])
kable_styling(kable(answer))
# set up the data we need for fr_cv
#data("my_penguins")
options(dplyr.summarise.inform = FALSE)
cv_error <- matrix(NA, nrow = 30 * 3, ncol = 2)
cv_error[, 1] <- rep(c(2, 5, 10), each = 30)
row <- 0
for(k in c(2, 5, 10)) {
for(i in 0:29) {
row <- row + 1
cv_error[row, 2] <- my_rf_cv(k)
}
}
#create the ggplot
my_df <- data.frame("mse" = cv_error[, 2], "k" = cv_error[, 1])
my_df %>%
ggplot(aes(x = factor(k), y = mse)) +
geom_boxplot() +
labs(title = "MSE", x = "Folds number", y = "MSE")
mse_sum <- my_df %>%
group_by(k) %>%
summarise(mean = mean(mse), sd = sd(mse))
kable_styling(kable(mse_sum))
# create the matrix
answer <- matrix(NA, nrow = 10, ncol = 2)
rownames(answer) <- c(1:10)
for (i in 1:10) {
output <- my_knn_cv(my_penguins_df[,3:6], my_penguins_df$species, i, 5)
answer[i, 1] <- output$ce
answer[i, 2] <- output$te
}
answer <- data.frame("Neighbour's number" = c(1:10),
"cv misclassification rate" = answer[, 1],
"training misclassification rate" = answer[, 2])
kable_styling(kable(answer))
